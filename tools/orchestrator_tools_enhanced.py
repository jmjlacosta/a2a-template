"""
Enhanced orchestrator tools that actually call agents and log communication.
"""

import json
import logging
from typing import Dict, Any, List, Optional
from google.adk.tools import FunctionTool
import asyncio
from utils.a2a_client import A2AAgentClient, AgentRegistry

# Configure logging
logger = logging.getLogger("OrchestratorTools")
logger.setLevel(logging.INFO)


async def call_keyword_agent(
    document_preview: str,
    focus_areas: Optional[List[str]] = None
) -> str:
    """
    Call the keyword agent to generate search patterns.
    
    Args:
        document_preview: Preview of the document to analyze
        focus_areas: Optional specific areas to focus on
        
    Returns:
        Search patterns generated by the keyword agent
    """
    logger.info("="*80)
    logger.info("ðŸ“¤ ORCHESTRATOR â†’ KEYWORD AGENT")
    logger.info("="*80)
    
    # Prepare the message for keyword agent
    message = f"""Generate regex patterns for finding medical information in this document:

{document_preview[:1000]}

{"Focus areas: " + ", ".join(focus_areas) if focus_areas else "Generate comprehensive patterns for all medical information."}"""
    
    logger.info(f"ðŸ“ Message being sent to keyword agent:")
    logger.info(f"   {message[:500]}..." if len(message) > 500 else f"   {message}")
    
    try:
        # Get keyword agent URL
        registry = AgentRegistry()
        keyword_url = registry.get_agent_url("keyword")
        if not keyword_url:
            keyword_url = "http://localhost:8002"
        
        # Call keyword agent
        async with A2AAgentClient(timeout=60.0) as client:
            response = await client.call_agent(keyword_url, message)
        
        logger.info(f"ðŸ“¥ Response from keyword agent:")
        logger.info(f"   {response[:500]}..." if len(response) > 500 else f"   {response}")
        logger.info("="*80)
        
        return response
        
    except Exception as e:
        logger.error(f"âŒ Error calling keyword agent: {e}")
        return f"Error: {str(e)}"


async def call_grep_agent(
    patterns: List[str],
    document_content: str,
    case_sensitive: bool = False
) -> str:
    """
    Call the grep agent to search for patterns.
    
    Args:
        patterns: Search patterns to use
        document_content: Document content to search
        case_sensitive: Whether to use case-sensitive search
        
    Returns:
        Search results from grep agent
    """
    logger.info("="*80)
    logger.info("ðŸ“¤ ORCHESTRATOR â†’ GREP AGENT")
    logger.info("="*80)
    
    # Prepare message for grep agent
    message = json.dumps({
        "patterns": patterns,
        "document_content": document_content,
        "case_sensitive": case_sensitive
    })
    
    logger.info(f"ðŸ“ Message being sent to grep agent:")
    logger.info(f"   Patterns: {patterns[:5]}..." if len(patterns) > 5 else f"   Patterns: {patterns}")
    logger.info(f"   Document length: {len(document_content)} characters")
    logger.info(f"   Case sensitive: {case_sensitive}")
    
    try:
        # Get grep agent URL
        registry = AgentRegistry()
        grep_url = registry.get_agent_url("grep")
        if not grep_url:
            grep_url = "http://localhost:8013"
        
        # Call grep agent
        async with A2AAgentClient(timeout=60.0) as client:
            response = await client.call_agent(grep_url, message)
        
        logger.info(f"ðŸ“¥ Response from grep agent:")
        logger.info(f"   {response[:500]}..." if len(response) > 500 else f"   {response}")
        logger.info("="*80)
        
        return response
        
    except Exception as e:
        logger.error(f"âŒ Error calling grep agent: {e}")
        return f"Error: {str(e)}"


async def call_chunk_agent(
    match_info: Dict[str, Any],
    lines_before: int = 3,
    lines_after: int = 3
) -> str:
    """
    Call the chunk agent to extract context.
    
    Args:
        match_info: Information about the match
        lines_before: Lines to include before match
        lines_after: Lines to include after match
        
    Returns:
        Extracted chunk from chunk agent
    """
    logger.info("="*80)
    logger.info("ðŸ“¤ ORCHESTRATOR â†’ CHUNK AGENT")
    logger.info("="*80)
    
    # Prepare message for chunk agent
    message = json.dumps({
        "match_info": match_info,
        "lines_before": lines_before,
        "lines_after": lines_after
    })
    
    logger.info(f"ðŸ“ Message being sent to chunk agent:")
    logger.info(f"   Match location: {match_info.get('line_number', 'unknown')}")
    logger.info(f"   Context: {lines_before} lines before, {lines_after} lines after")
    
    try:
        # Get chunk agent URL
        registry = AgentRegistry()
        chunk_url = registry.get_agent_url("chunk")
        if not chunk_url:
            chunk_url = "http://localhost:8004"
        
        # Call chunk agent
        async with A2AAgentClient(timeout=60.0) as client:
            response = await client.call_agent(chunk_url, message)
        
        logger.info(f"ðŸ“¥ Response from chunk agent:")
        logger.info(f"   {response[:500]}..." if len(response) > 500 else f"   {response}")
        logger.info("="*80)
        
        return response
        
    except Exception as e:
        logger.error(f"âŒ Error calling chunk agent: {e}")
        return f"Error: {str(e)}"


async def call_summarize_agent(
    chunk_content: str,
    chunk_metadata: Optional[Dict[str, Any]] = None,
    summary_style: str = "clinical"
) -> str:
    """
    Call the summarize agent to analyze chunks.
    
    Args:
        chunk_content: Content to summarize
        chunk_metadata: Optional metadata about the chunk
        summary_style: Style of summary (clinical, natural, structured)
        
    Returns:
        Summary from summarize agent
    """
    logger.info("="*80)
    logger.info("ðŸ“¤ ORCHESTRATOR â†’ SUMMARIZE AGENT")
    logger.info("="*80)
    
    # Prepare message for summarize agent
    message = json.dumps({
        "chunk_content": chunk_content,
        "chunk_metadata": chunk_metadata or {},
        "summary_style": summary_style
    })
    
    logger.info(f"ðŸ“ Message being sent to summarize agent:")
    logger.info(f"   Content length: {len(chunk_content)} characters")
    logger.info(f"   Summary style: {summary_style}")
    
    try:
        # Get summarize agent URL
        registry = AgentRegistry()
        summarize_url = registry.get_agent_url("summarize")
        if not summarize_url:
            summarize_url = "http://localhost:8005"
        
        # Call summarize agent
        async with A2AAgentClient(timeout=60.0) as client:
            response = await client.call_agent(summarize_url, message)
        
        logger.info(f"ðŸ“¥ Response from summarize agent:")
        logger.info(f"   {response[:500]}..." if len(response) > 500 else f"   {response}")
        logger.info("="*80)
        
        return response
        
    except Exception as e:
        logger.error(f"âŒ Error calling summarize agent: {e}")
        return f"Error: {str(e)}"


# Wrapper functions for synchronous use with Google ADK
def call_keyword_agent_sync(document_preview: str, focus_areas: Optional[List[str]] = None) -> str:
    """Synchronous wrapper for call_keyword_agent."""
    return asyncio.run(call_keyword_agent(document_preview, focus_areas))

def call_grep_agent_sync(patterns: List[str], document_content: str, case_sensitive: bool = False) -> str:
    """Synchronous wrapper for call_grep_agent."""
    return asyncio.run(call_grep_agent(patterns, document_content, case_sensitive))

def call_chunk_agent_sync(match_info: Dict[str, Any], lines_before: int = 3, lines_after: int = 3) -> str:
    """Synchronous wrapper for call_chunk_agent."""
    return asyncio.run(call_chunk_agent(match_info, lines_before, lines_after))

def call_summarize_agent_sync(chunk_content: str, chunk_metadata: Optional[Dict[str, Any]] = None, summary_style: str = "clinical") -> str:
    """Synchronous wrapper for call_summarize_agent."""
    return asyncio.run(call_summarize_agent(chunk_content, chunk_metadata, summary_style))


# Create FunctionTool instances for Google ADK
keyword_tool = FunctionTool(func=call_keyword_agent_sync)
grep_tool = FunctionTool(func=call_grep_agent_sync)
chunk_tool = FunctionTool(func=call_chunk_agent_sync)
summarize_tool = FunctionTool(func=call_summarize_agent_sync)

# Export enhanced tools
ENHANCED_ORCHESTRATOR_TOOLS = [
    keyword_tool,
    grep_tool,
    chunk_tool,
    summarize_tool
]