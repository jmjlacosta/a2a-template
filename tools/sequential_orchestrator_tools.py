"""
Fixed orchestrator tools that properly handle async execution per A2A spec.
These tools actually call agents and log communication details.
"""

import json
import logging
from typing import Dict, Any, List, Optional
from google.adk.tools import FunctionTool
from utils.a2a_client import A2AAgentClient, AgentRegistry

# Configure logging
logger = logging.getLogger("OrchestratorTools")
logger.setLevel(logging.INFO)


async def call_keyword_agent(
    document_preview: str,
    focus_areas: Optional[List[str]] = None
) -> str:
    """
    Call the keyword agent to generate search patterns.
    
    Args:
        document_preview: Preview of the document to analyze
        focus_areas: Optional specific areas to focus on
        
    Returns:
        Search patterns generated by the keyword agent
    """
    logger.info("="*80)
    logger.info("üì§ ORCHESTRATOR ‚Üí KEYWORD AGENT")
    logger.info("="*80)
    
    # Prepare the message for keyword agent
    message = f"""Generate regex patterns for finding medical information in this document:

{document_preview[:1000]}

{"Focus areas: " + ", ".join(focus_areas) if focus_areas else "Generate comprehensive patterns for all medical information."}"""
    
    logger.info(f"üìù Message being sent to keyword agent:")
    logger.info(f"   {message[:500]}..." if len(message) > 500 else f"   {message}")
    
    try:
        # Get keyword agent URL
        registry = AgentRegistry()
        keyword_url = registry.get_agent_url("keyword")
        if not keyword_url:
            keyword_url = "http://localhost:8002"
        
        # Call keyword agent
        async with A2AAgentClient(timeout=60.0) as client:
            response = await client.call_agent(keyword_url, message)
        
        logger.info(f"üì• Response from keyword agent:")
        logger.info(f"   {response[:500]}..." if len(response) > 500 else f"   {response}")
        logger.info("="*80)
        
        return response
        
    except Exception as e:
        logger.error(f"‚ùå Error calling keyword agent: {e}")
        return f"Error: {str(e)}"


async def call_grep_agent(
    patterns: List[str],
    document_content: str,
    case_sensitive: bool = False
) -> str:
    """
    Call the grep agent to search for patterns.
    
    Args:
        patterns: Search patterns to use
        document_content: Document content to search
        case_sensitive: Whether to use case-sensitive search
        
    Returns:
        Search results from grep agent
    """
    logger.info("="*80)
    logger.info("üì§ ORCHESTRATOR ‚Üí GREP AGENT")
    logger.info("="*80)
    
    # Prepare message for grep agent
    message = json.dumps({
        "patterns": patterns,
        "document_content": document_content,
        "case_sensitive": case_sensitive
    })
    
    logger.info(f"üìù Message being sent to grep agent:")
    logger.info(f"   Patterns: {patterns[:5]}..." if len(patterns) > 5 else f"   Patterns: {patterns}")
    logger.info(f"   Document length: {len(document_content)} characters")
    logger.info(f"   Case sensitive: {case_sensitive}")
    
    try:
        # Get grep agent URL
        registry = AgentRegistry()
        grep_url = registry.get_agent_url("grep")
        if not grep_url:
            grep_url = "http://localhost:8013"
        
        # Call grep agent
        async with A2AAgentClient(timeout=60.0) as client:
            response = await client.call_agent(grep_url, message)
        
        logger.info(f"üì• Response from grep agent:")
        logger.info(f"   {response[:500]}..." if len(response) > 500 else f"   {response}")
        logger.info("="*80)
        
        return response
        
    except Exception as e:
        logger.error(f"‚ùå Error calling grep agent: {e}")
        return f"Error: {str(e)}"


async def call_chunk_agent(
    match_info: Dict[str, Any],
    lines_before: int = 3,
    lines_after: int = 3
) -> str:
    """
    Call the chunk agent to extract context.
    
    Args:
        match_info: Information about the match
        lines_before: Lines to include before match
        lines_after: Lines to include after match
        
    Returns:
        Extracted chunk from chunk agent
    """
    logger.info("="*80)
    logger.info("üì§ ORCHESTRATOR ‚Üí CHUNK AGENT")
    logger.info("="*80)
    
    # Prepare message for chunk agent
    message = json.dumps({
        "match_info": match_info,
        "lines_before": lines_before,
        "lines_after": lines_after
    })
    
    logger.info(f"üìù Message being sent to chunk agent:")
    logger.info(f"   Match location: {match_info.get('line_number', 'unknown')}")
    logger.info(f"   Context: {lines_before} lines before, {lines_after} lines after")
    
    try:
        # Get chunk agent URL
        registry = AgentRegistry()
        chunk_url = registry.get_agent_url("chunk")
        if not chunk_url:
            chunk_url = "http://localhost:8004"
        
        # Call chunk agent
        async with A2AAgentClient(timeout=60.0) as client:
            response = await client.call_agent(chunk_url, message)
        
        logger.info(f"üì• Response from chunk agent:")
        logger.info(f"   {response[:500]}..." if len(response) > 500 else f"   {response}")
        logger.info("="*80)
        
        return response
        
    except Exception as e:
        logger.error(f"‚ùå Error calling chunk agent: {e}")
        return f"Error: {str(e)}"


async def call_summarize_agent(
    chunk_content: str,
    chunk_metadata: Optional[Dict[str, Any]] = None,
    summary_style: str = "clinical"
) -> str:
    """
    Call the summarize agent to analyze chunks.
    
    Args:
        chunk_content: Content to summarize
        chunk_metadata: Optional metadata about the chunk
        summary_style: Style of summary (clinical, natural, structured)
        
    Returns:
        Summary from summarize agent
    """
    logger.info("="*80)
    logger.info("üì§ ORCHESTRATOR ‚Üí SUMMARIZE AGENT")
    logger.info("="*80)
    
    # Prepare message for summarize agent
    message = json.dumps({
        "chunk_content": chunk_content,
        "chunk_metadata": chunk_metadata or {},
        "summary_style": summary_style
    })
    
    logger.info(f"üìù Message being sent to summarize agent:")
    logger.info(f"   Content length: {len(chunk_content)} characters")
    logger.info(f"   Summary style: {summary_style}")
    
    try:
        # Get summarize agent URL
        registry = AgentRegistry()
        summarize_url = registry.get_agent_url("summarize")
        if not summarize_url:
            summarize_url = "http://localhost:8005"
        
        # Call summarize agent
        async with A2AAgentClient(timeout=60.0) as client:
            response = await client.call_agent(summarize_url, message)
        
        logger.info(f"üì• Response from summarize agent:")
        logger.info(f"   {response[:500]}..." if len(response) > 500 else f"   {response}")
        logger.info("="*80)
        
        return response
        
    except Exception as e:
        logger.error(f"‚ùå Error calling summarize agent: {e}")
        return f"Error: {str(e)}"


async def call_any_agent(
    agent_name: str,
    message: str,
    timeout: float = 60.0
) -> str:
    """
    Generic function to call any agent by name.
    
    Args:
        agent_name: Name of the agent (from config/agents.json) or direct URL
        message: Message to send to the agent
        timeout: Request timeout in seconds
        
    Returns:
        Response from the agent
    """
    logger.info("="*80)
    logger.info(f"üì§ ORCHESTRATOR ‚Üí {agent_name.upper()}")
    logger.info("="*80)
    
    logger.info(f"üìù Message being sent:")
    logger.info(f"   {message[:500]}..." if len(message) > 500 else f"   {message}")
    
    try:
        # Check if it's a URL or agent name
        if agent_name.startswith(('http://', 'https://')):
            agent_url = agent_name
        else:
            # Get agent URL from registry
            registry = AgentRegistry()
            agent_url = registry.get_agent_url(agent_name)
            if not agent_url:
                # Try localhost with common ports
                port_map = {
                    "keyword": 8002,
                    "grep": 8013,
                    "chunk": 8004,
                    "summarize": 8005,
                    "summarizer": 8005,
                    "orchestrator": 8006
                }
                port = port_map.get(agent_name.lower())
                if port:
                    agent_url = f"http://localhost:{port}"
                else:
                    raise ValueError(f"Agent '{agent_name}' not found in registry")
        
        # Call the agent
        async with A2AAgentClient(timeout=timeout) as client:
            response = await client.call_agent(agent_url, message)
        
        logger.info(f"üì• Response from {agent_name}:")
        logger.info(f"   {response[:500]}..." if len(response) > 500 else f"   {response}")
        logger.info("="*80)
        
        return response
        
    except Exception as e:
        logger.error(f"‚ùå Error calling {agent_name}: {e}")
        return f"Error calling {agent_name}: {str(e)}"


# Create FunctionTool instances for Google ADK
# These now properly handle async functions
keyword_tool = FunctionTool(func=call_keyword_agent)
grep_tool = FunctionTool(func=call_grep_agent)
chunk_tool = FunctionTool(func=call_chunk_agent)
summarize_tool = FunctionTool(func=call_summarize_agent)
generic_agent_tool = FunctionTool(func=call_any_agent)

# Export fixed tools
FIXED_ORCHESTRATOR_TOOLS = [
    keyword_tool,
    grep_tool,
    chunk_tool,
    summarize_tool,
    generic_agent_tool
]